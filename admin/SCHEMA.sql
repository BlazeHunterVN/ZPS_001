-- Run this in your Supabase SQL Editor

-- [WARNING] This will DELETE existing data in these tables. 
DROP TABLE IF EXISTS public.nation_banners;
DROP TABLE IF EXISTS public.home_settings;
DROP TABLE IF EXISTS public.admin_access;

-- 1. Create Nation Banners Table
create table public.nation_banners (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  title text,
  url text not null,
  banner_link text,
  start_date text,
  end_date text,
  nation_key text not null
);

-- 2. Create Home Settings Table
create table public.home_settings (
  id int primary key default 1,
  bg_pc_url text,
  bg_mobile_url text,
  constraint check_id check (id = 1)
);

-- 3. Create Admin Access Table
create table public.admin_access (
  id bigint generated by default as identity primary key,
  email text unique not null,
  access_key text not null,
  role text default 'admin' check (role in ('admin', 'senior_admin'))
);

-- 5. Enable Realtime for tables
-- This is REQUIRED for the website to update automatically without reload
-- Note: If you get an error saying the table is already in a publication, simply ignore it.
DO $$ 
BEGIN
  -- We don't use DROP TABLE IF EXISTS here as it's not supported in all Postgres versions for publications
  -- Instead, we just try to add them.
  BEGIN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.nation_banners;
  EXCEPTION WHEN OTHERS THEN 
    RAISE NOTICE 'Table nation_banners already in publication or other error info: %', SQLERRM;
  END;

  BEGIN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.home_settings;
  EXCEPTION WHEN OTHERS THEN 
    RAISE NOTICE 'Table home_settings already in publication or other error info: %', SQLERRM;
  END;
END $$;

-- 6. Policies for nation_banners
create policy "Allow public read access" on public.nation_banners for select using (true);

-- 6. Policies for home_settings
create policy "Allow public read access" on public.home_settings for select using (true);

-- 7. Policies for admin_access
-- Only allow reading by authenticated users who are in the table (for self-verification or senior admin listing)
create policy "Allow read for admins" on public.admin_access for select using (true); 

-- 8. RPC Functions for Secure Banner Management

-- Clean up existing functions to avoid ambiguity (Function Overloading)
DROP FUNCTION IF EXISTS public.verify_admin_key(text, text);
DROP FUNCTION IF EXISTS public.manage_banner_upsert(text, text, bigint, text, text, text, text, text, text);
DROP FUNCTION IF EXISTS public.manage_banner_upsert(text, text, bigint, text, text, text, text, text, text, text);
DROP FUNCTION IF EXISTS public.manage_banner_delete(text, text, bigint[]);
DROP FUNCTION IF EXISTS public.manage_home_settings(text, text, text, text);
DROP FUNCTION IF EXISTS public.manage_admin_access(text, text, text, text, text, text);

-- Verify Admin Key
create or replace function public.verify_admin_key(p_email text, p_key text)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
begin
  return exists (
    select 1 
    from public.admin_access 
    where email = p_email and access_key = p_key
  );
end;
$$;

-- Upsert Banner (Add/Edit)
create or replace function public.manage_banner_upsert(
    p_email text,
    p_key text,
    p_id bigint default null,
    p_title text default null,
    p_url text default null,
    p_banner_link text default null,
    p_nation_key text default null,
    p_start_date text default null,
    p_end_date text default null
)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
    v_is_valid boolean;
begin
    v_is_valid := public.verify_admin_key(p_email, p_key);
    if not v_is_valid then raise exception 'Unauthorized access'; end if;

    if p_id is not null then
        update public.nation_banners
        set title = p_title,
            url = p_url,
            banner_link = p_banner_link,
            nation_key = p_nation_key,
            start_date = p_start_date,
            end_date = p_end_date
        where id = p_id;
        return json_build_object('status', 'updated', 'id', p_id);
    else
        insert into public.nation_banners (title, url, banner_link, nation_key, start_date, end_date)
        values (p_title, p_url, p_banner_link, p_nation_key, p_start_date, p_end_date)
        returning id into p_id;
        return json_build_object('status', 'inserted', 'id', p_id);
    end if;
end;
$$;

-- Delete Banner
create or replace function public.manage_banner_delete(
    p_email text,
    p_key text,
    p_ids bigint[]
)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
    v_is_valid boolean;
begin
    v_is_valid := public.verify_admin_key(p_email, p_key);
    if not v_is_valid then raise exception 'Unauthorized access'; end if;

    delete from public.nation_banners
    where id = any(p_ids);
    
    return json_build_object('status', 'deleted', 'count', array_length(p_ids, 1));
end;
$$;

-- Update Home Settings
create or replace function public.manage_home_settings(
    p_email text,
    p_key text,
    p_bg_pc_url text,
    p_bg_mobile_url text
)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
    v_is_valid boolean;
begin
    v_is_valid := public.verify_admin_key(p_email, p_key);
    if not v_is_valid then raise exception 'Unauthorized access'; end if;

    insert into public.home_settings (id, bg_pc_url, bg_mobile_url)
    values (1, p_bg_pc_url, p_bg_mobile_url)
    on conflict (id) do update
    set bg_pc_url = excluded.bg_pc_url,
        bg_mobile_url = excluded.bg_mobile_url;
    
    return json_build_object('status', 'success');
end;
$$;

-- Manage Admin Access (Grant Access)
create or replace function public.manage_admin_access(
    p_email text,
    p_key text,
    p_action text, -- 'ADD', 'DELETE', 'UPDATE'
    p_target_email text,
    p_target_password text default null,
    p_target_role text default 'admin'
)
returns json
language plpgsql
security definer
set search_path = public
as $$
declare
    v_role text;
begin
    -- Check if requester is Senior Admin
    select role into v_role from public.admin_access where email = p_email and access_key = p_key;
    
    if v_role is null or v_role != 'senior_admin' then
        raise exception 'Unauthorized: Only Senior Admins can manage access.';
    end if;

    if p_action = 'ADD' then
        insert into public.admin_access (email, access_key, role)
        values (p_target_email, p_target_password, p_target_role);
        return json_build_object('status', 'added', 'email', p_target_email);

    elsif p_action = 'UPDATE' then
        update public.admin_access
        set access_key = coalesce(p_target_password, access_key),
            role = coalesce(p_target_role, role)
        where email = p_target_email;
        return json_build_object('status', 'updated', 'email', p_target_email);

    elsif p_action = 'DELETE' then
        delete from public.admin_access where email = p_target_email;
        return json_build_object('status', 'deleted', 'email', p_target_email);
    
    else
        raise exception 'Invalid action';
    end if;
end;
$$;

-- Seed Data
insert into public.admin_access (email, access_key, role) 
values ('blazehunter01062008@gmail.com', 'Nguyenminhkhoi208160!', 'senior_admin')
on conflict (email) do update set role = 'senior_admin';

insert into public.home_settings (id, bg_pc_url, bg_mobile_url)
values (1, '', '')
on conflict (id) do nothing;
